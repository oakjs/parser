statement define_type
    english
        define type {name:type} {nestedBlock}
    js
        class $name $nestedBlock
    tests english => js
        define type Animal => class Animal {}


statement define_subtype
    english
        define type {name:type} as (a|an) {superType:type} {nestedBlock}
    js
        class $name extends $superType $nestedBlock
    tests english => js
        define type Mammal as an Animal => class Mammal extends Animal {}

statement new_thing, expression
    english
        (create (a|an)|make a new) {type} (?:with {props:object_literal_properties})?
//TODO: (props|properties) {props:expression}
    js
        new $type($props)
    tests english => js
        create an Animal => new Animal()
        create a Mammal => new Mammal()
        make a new Animal => new Animal()
        make a new Animal with species "Cheetah" => new Animal({ species: "Cheetah" })
        make a new Animal with species "Cheetah" and name "Bob" => new Animal({ species: "Cheetah", name: "Bob" })
    note
        Assumes all objects take an object literal on creation...?


statement declare_method
    english
        (to|on) {name:identifier} {args}? (\\:)? {nestedBlock}
    js
        $name(${args.join(", ")}) $nestedBlock
    tests english => js
        to
    note
        assumes event delegation works automatically, eg: "click" method automatically reacts to "click" event
