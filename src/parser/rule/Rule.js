//  # Parser Rules
//  Rules can be as simple as a string `Keyword` or a complex sequence of (nested) rules.
//
//  Parse a rule with `rule.parse(scope, tokens)`.
//  If UNSUCCESSFUL, it will return `undefined`
//  If SUCCESSFUL,   it will return a new `Match()` object which is guaranteed to have:
//    - `match.rule`        : pointer back to the rule.
//    - `match.matched`     : array of *significant* tokens that were actually matched.
//    - `match.length` : number of tokens actually consumed (`matched` may not contain them all)
//    ... and other rule-specific values.
//
//  The match returned can be manipulated with:
//    - `match.compile()`    Return javascript source to interpret the rule.
//

import { TestLocation } from "../constants"
import { proto } from "../../util/decorators"

// Abstract Rule class.
// TODOC
export class Rule {
  // Precedence for this rule.
  // Rules with higher precedence are preferred in `Choice`s.
  // Precedence is also used as "operator precedence" in recursive expressions.
  @proto precedence = 0

  constructor(props) {
    Object.assign(this, props)
  }

  // Return a clone of this rule (same constructor, all public properties)
  clone() {
    return new this.constructor(this)
  }

  //
  //  Parsing methods -- you MUST implement these in your subclasses!
  //

  // Test to see if there is ANY WAY that we can be found
  // starting at `start` position of `tokens`.
  //
  // This is used to exit quickly if there is no chance of success,
  //  and is especially useful for rules which call themselves recursively.
  //
  // Returns:
  //  - `true` if the rule MIGHT be matched.
  //  - `false` if there is NO WAY the rule can be matched.
  //  - `undefined` if not determinstic (eg: no way to tell quickly).
  testAtStart(scope, tokens, start = 0) {
    if (start >= tokens.length) return false
    if (this.testRule) return this.testRule.testAtStart(scope, tokens, start)
    return undefined
  }

  // Attempt to match this rule at the start of `tokens`.
  // If successful, returns a `Match` object which you can use to figure out the results.
  // If unsuccessful, returns `undefined`.
  parse(scope, tokens) {}

  // Output javascript source for this rule passed a successful `match` generated by it.
  // You may want to look at `match.matched` or `match.results`, etc.
  compile(match) {}

  //
  //  internal
  //

  // Test to see if this rule is matched in `tokens`.
  //
  // You shouldn't override this, override `testAtStart()` instead,
  // or just provide a `testRule`.
  //
  // By default, we respect our `testLocation` parameter to test
  //  either at the beginning of the tokens or anywhere in the run.
  // Sometimes rules want to override the `testLocation`, e.g.
  //  so allow it to be passed in.
  test(scope, tokens, testLocation = this.testLocation) {
    if (!tokens.length) return false
    if (this.testRule) return this.testRule.test(scope, tokens, testLocation)

    if (testLocation === TestLocation.ANYWHERE) return this.testAnywhere(scope, tokens)
    return this.testAtStart(scope, tokens, 0)
  }

  // Test if this rule is matched anywhere in the tokens
  //  by exhaustively testing at each start position.
  testAnywhere(scope, tokens) {
    let undefinedFound = false
    for (let start = 0, last = tokens.length; start < last; start++) {
      const result = this.testAtStart(scope, tokens, start)
      if (result) return true
      if (result === undefined) undefinedFound = true
    }
    if (undefinedFound) return undefined
    return false
  }

  // We attempt to merge literals together if possible when creating rules.
  // We can only do that for ruls that are not "adorned" with argument, etc.
  // Note that `optional` doesn't matter in this case, because we can merge
  //  optional and non-optional literals.
  get isAdorned() {
    return !!(this.argument || this.testLocation || this.isEscaped)
  }

  // Return syntax string for this rule (doesn't apply to all rule types).
  // The base implementation takes care of the "adornments" and returns an object with:
  //  `{ testLocation, argument, optional }`
  getSyntaxFlags() {
    let { testLocation = "", argument = "", optional = "" } = this
    if (testLocation === TestLocation.ANYWHERE) testLocation = "â€¦"
    else if (testLocation === TestLocation.ANYWHERE) testLocation = "^"
    if (argument) argument += ":"
    if (optional) optional = "?"
    return { testLocation, argument, optional }
  }
}
