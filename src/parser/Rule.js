//  # Parser Rules
//  Rules can be as simple as a string `Keyword` or a complex sequence of (nested) rules.
//
//  Parse a rule with `rule.parse(scope, tokens)`.
//  If UNSUCCESSFUL, it will return `undefined`
//  If SUCCESSFUL,   it will return a new `Match()` object which is guaranteed to have:
//    - `match.rule`        : pointer back to the rule.
//    - `match.matched`     : array of *significant* tokens that were actually matched.
//    - `match.matchLength` : number of tokens actually consumed (`matched` may not contain them all)
//    ... and other rule-specific values.
//
//  The match returned can be manipulated with:
//    - `match.compile()`    Return javascript source to interpret the rule.
//
import { isNode } from "browser-or-node";

import {
  Match,
  Token,

  isWhitespace,
  proto
} from "./all.js";


// Show debug messages on browser only.
const DEBUG = false;//!isNode;

// Should we test at the start of the tokens, or anywhere in the range?
export const TestLocation = {
  AT_START: "AT_START",
  ANYWHERE: "ANYWHERE"
};

// Abstract Rule class.
// TODOC
export class Rule {
  constructor(props) {
    Object.assign(this, props);
  }

  // Return a clone of this rule (same constructor, all public properties)
  clone() {
    return new (this.constructor)(this);
  }

  //
  //  Parsing methods -- you MUST implement these in your subclasses!
  //

  // Test to see if there is ANY WAY that we can be found
  // starting at `start` position of `tokens`.
  //
  // This is used to exit quickly if there is no chance of success,
  //  and is especially useful for rules which call themselves recursively.
  //
  // Returns:
  //  - `true` if the rule MIGHT be matched.
  //  - `false` if there is NO WAY the rule can be matched.
  //  - `undefined` if not determinstic (eg: no way to tell quickly).
  testAtStart(scope, tokens, start = 0) {
    if (start >= tokens.length) return false;
    if (this.testRule) return this.testRule.testAtStart(scope, tokens, start);
  }

  // Attempt to match this rule at the start of `tokens`.
  // If successful, returns a `Match` object which you can use to figure out the results.
  // If unsuccessful, returns `undefined`.
  parse(scope, tokens) {}

  // Output javascript source for this rule passed a successful `match` generated by it.
  // You may want to look at `match.matched` or `match.results`, etc.
  compile(match) {}

  // Return the precedence for this rule as matched.
  // Override to do something funky.
  @proto precedence = 0;
  getPrecedence(match) {
    return this.precedence;
  }


  //
  //  internal
  //

  // Test to see if this rule is matched in `tokens`.
  //
  // You shouldn't override this, override `testAtStart()` instead,
  // or just provide a `testRule`.
  //
  // By default, we respect our `testLocation` parameter to test
  //  either at the beginning of the tokens or anywhere in the run.
  // Sometimes rules want to override the `testLocation`, e.g.
  //  so allow it to be passed in.
  test(scope, tokens, testLocation = this.testLocation) {
    if (!tokens.length) return false;
    if (this.testRule) return this.testRule.test(scope, tokens, testLocation);

    if (testLocation === TestLocation.ANYWHERE)
      return this.testAnywhere(scope, tokens);
    return this.testAtStart(scope, tokens, 0);
  }

  // Test if this rule is matched anywhere in the tokens
  //  by exhaustively testing at each start position.
  testAnywhere(scope, tokens) {
    let undefinedFound = false;
    for (let start = 0, length = tokens.length; start < length; start++) {
      const result = this.testAtStart(scope, tokens, start);
      if (result === true) return true;
      if (result === undefined) undefinedFound = true;
    }
    if (undefinedFound) return undefined;
    return false;
  }

  // We attempt to merge literals together if possible when creating rules.
  // We can only do that for ruls that are not "adorned" with promote, argument, etc.
  get isAdorned() {
    return !!(this.optional || this.promote || this.argument || this.testLocation || this.isEscaped);
  }

  // Return syntax string for this rule (doesn't apply to all rule types).
  // The base implementation takes care of the "adornments" and returns an object with:
  //  `{ testLocation, promote, argument, optional }`
  getSyntaxFlags() {
    let { testLocation = "", promote = "", argument = "", optional = "" } = this;
    if (testLocation === TestLocation.ANYWHERE) testLocation = "â€¦";
    else if (testLocation === TestLocation.ANYWHERE) testLocation = "^";
    if (promote) promote = "?:";
    if (argument) argument += ":";
    if (optional) optional = "?";
    return { testLocation, promote, argument, optional };
  }
}

// Abstract rule for matching tokens of a particular type (Token constructor)
Rule.TokenType = class tokenType extends Rule {
  testAtStart(scope, tokens, start = 0) {
    return (tokens[start] instanceof this.tokenType);
  }

  parse(scope, tokens) {
    if (!this.testAtStart(scope, tokens, 0)) return undefined;
    return new Match({
      rule: this,
      matched: [tokens[0]],
      matchLength: 1,
      scope
    });
  }

  compile(match) {
    return match.matched[0].value;
  }
}

// Match a single Word
Rule.Word = class word extends Rule.TokenType {
  @proto name = "word";
  @proto tokenType = Token.Word;
}


// Abstract rule to match a single literal value.
// `rule.literal` is either:
//    - string to match, or
//    - array of strings, any of which will work.
Rule.Literal = class literal extends Rule {
  constructor(props) {
    if (Array.isArray(props)) props = { literal: props };
    if (typeof props === "string") props = { literal: props };
    super(props);
  }

  testAtStart(scope, tokens, start = 0) {
    if (start >= tokens.length) return false;
    return tokens[start].matchesLiteral(this.literal);
  }

  parse(scope, tokens) {
    if (!this.testAtStart(scope, tokens, 0)) return undefined;
    return new Match({
      rule: this,
      matched: [tokens[0]],
      matchLength: 1,
      scope
    });
  }

  compile(match) {
    return match.matched[0].value;
  }

  toSyntax() {
    const { testLocation, promote, argument, optional } = this.getSyntaxFlags();
    const isVariable = Array.isArray(this.literal);
    const literal = isVariable
      ? this.literal.join("|")
      : (this.isEscaped ? `\\${this.literal}` : this.literal);

    const wrapInParens = isVariable || promote || argument || (this.isEscaped && optional);
    if (wrapInParens)
      return `${testLocation}(${promote}${argument}${literal})${optional}`;
    return `${testLocation}${literal}${optional}`;
  }
};

// Syntactic sugar for composing rules.
Rule.Keyword = class keyword extends Rule.Literal {}
Rule.Symbol = class symbol extends Rule.Literal {}

// Abstract rule for one or more sequential literal values to match.
// `rule.literals`:
//    the literal string or array of literal strings to match.
// `rule.literalSeparator`
//    the string to put between multiple literals when joining multiple literals together.
Rule.Literals = class literals extends Rule {
  // By default, join literals with no space between
  @proto literalSeparator = "";

  constructor(props) {
    if (arguments.length > 1) props = [...arguments];
    if (Array.isArray(props)) props = { literals: props };
    if (typeof props === "string") props = { literals: props };
    super(props);

    // coerce `literals` string to an array
    if (typeof this.literals === "string") {
      this.literals = this.literals.split(this.literalSeparator);
    }
  }

  testAtStart(scope, tokens, start = 0) {
    const literals = this.literals;
    const length = literals.length;
    if (start + length > tokens.length) return false;

    // Quick return if only one.
    if (length === 1) return tokens[start].matchesLiteral(literals[0]);

    // if more than one, make sure all the rest match
    for (let i = 0; i < length; i++) {
      if (!tokens[start + i].matchesLiteral(literals[i])) return false;
    }
    return true;
  }

  parse(scope, tokens) {
    if (!this.testAtStart(scope, tokens, 0)) return undefined;
    const matchLength = this.literals.length;
    return new Match({
      rule: this,
      matched: tokens.slice(0, matchLength),
      matchLength,
      scope
    });
  }

  compile(match) {
    return match.matched
      .map(match => match.value)
      .join(this.literalSeparator);
  }

  getInputText(match) {
    return this.compile(match);
  }

  toSyntax() {
    const { testLocation, promote, argument, optional } = this.getSyntaxFlags();

    const literals = this.literals.map(literal => {
      if (typeof literal === "string") return literal;
      return `(${literal.join("|")})`;
    }).join(this.literalSeparator);

    const wrapInParens =
      promote ||
      argument ||
      ((testLocation || optional) && this.literals.length > 1)
    ;
    if (wrapInParens)
      return `${testLocation}(${promote}${argument}${literals})${optional}`;
    return `${testLocation}${literals}${optional}`;
  }
};

// One or more literal symbols: `<`, `%` etc.
// Symbols join WITHOUT spaces.
Rule.Symbols = class symbols extends Rule.Literals {};

// One or more literal keywords.
// Keywords join WITH spaces.
Rule.Keywords = class keywords extends Rule.Literals {
  // Join literals with a space in-between.
  @proto literalSeparator = " ";

  // If we ended up with only one literal, return a Keyword
  constructor() {
    super(...arguments);
    if (this.literals && this.literals.length === 1) {
      const { literals, ...props } = this;
      return new Rule.Keyword({ ...props, literal: literals[0] });
    }
  }
};

// Regex pattern to match a SINGLE token.
// `rule.pattern` is the regular expression to match.
//    Note that you MUST start your pattern with `^` and end with `$` to make sure it matches the entire token.
//    Note that this can only match a single token!
// `rule.blacklist` is a map of `{ key: true }` for strings which will NOT be accepted.
// `rule.valueMap` can be either:
//    - a map of `{ <matchedValue>: <returnValue> }` to map result output, or
//    - a `function(value) => newValue` used to transform the matched value.
Rule.Pattern = class pattern extends Rule {
  constructor(props) {
    if (props instanceof RegExp) props = { pattern: props };
    super(props);
    // convert blacklist to a map if necessary
    if (Array.isArray(this.blacklist)) {
      this.blacklist = this.blacklist.reduce((map, key) => {
        map[key] = true;
        return map;
      }, {});
    }
  }

  testAtStart(scope, tokens, start = 0) {
    if (start >= tokens.length) return false;
    return tokens[start].matchesPattern(this.pattern, this.blacklist);
  }

  parse(scope, tokens) {
    if (!this.testAtStart(scope, tokens, 0)) return undefined;
    return new Match({
      rule: this,
      matched: [tokens[0]],
      matchLength: 1,
      scope
    });
  }

  compile(match) {
    const value = match.matched[0].value;
    // just return value if no valuemap
    let { valueMap } = this;
    if (!valueMap) return value;
    if (typeof valueMap !== "function") {
      if (valueMap.hasOwnProperty(value)) return valueMap[value];
      if (typeof valueMap.default === "function") valueMap = valueMap.default;
    }
    if (typeof valueMap === "function") return valueMap(value);
    return value;
  }
};

// Subrule -- name of another rule to be called.
// `rule.rule` is the name of the rule in `scope.rules`.
// `rule.excludes` is an array of rule names we'll ignore when parsing this rule.
//
// After parsing
//  we'll return the actual rule that was matched (rather than a clone of this rule)
Rule.Subrule = class subrule extends Rule {
  constructor(props) {
    if (typeof props === "string") props = { rule: props };
    super(props);
  }

  // Ask the subrule to figure out if a match is possible.
  test(scope, tokens, testLocation = this.testLocation) {
    const rule = scope.getRuleOrDie(this.rule);
    return rule.test(scope, tokens, testLocation);
  }

  parse(scope, tokens) {
    if (!tokens.length) return;
    if (this.resetRules) scope = scope.resetRules();

    // if we have any excludes, get a clone of the scope without those rules
    if (this.excludes) {
      scope = scope.cloneExcludingRules(this.rule, this.excludes);
    }
    let rule = scope.getRuleOrDie(this.rule);

    const match = rule.parse(scope, tokens);
    if (!match) return undefined;
    if (this.argument) match.argument = this.argument;
    if (this.promote) match.promote = this.promote;
    return match;
  }

  toSyntax() {
    const { testLocation, promote, argument, optional } = this.getSyntaxFlags();
    const excludes = this.excludes ? `!${this.excludes.join("!")}` : "";
    return (
      `${testLocation}{${promote}${argument}${this.rule}${excludes}}${optional}`
    );
  }
};

// Alternative syntax, matching one of a number of different rules.
// The result of a parse is the longest rule that actually matched.
// NOTE: Currently takes the longest valid match.
// TODO: match all valid choices
//
// After parsing
//  we'll return the rule which is the "best match" (rather than cloning this rule).
Rule.Choice = class choices extends Rule {
  constructor(props) {
    if (arguments.length > 1) props = [...arguments];
    if (Array.isArray(props)) props = { rules: props };
    super(props);
    if (!this.rules) this.rules = [];
  }

  // Return (`true` or index) if ANY of our rules is found.
  // If ANY rules return `undefined`, this will return `undefined`.
  // If ALL rules return `false`, this will return `false`.
  testAtStart(scope, tokens, start = 0) {
    if (start >= tokens.length) return false;
    let undefinedFound = false;
    for (let i = 0, rule; rule = this.rules[i]; i++) {
      const result = rule.testAtStart(scope, tokens, start);
      if (result === true) return true;
      if (result === undefined) undefinedFound = true;
    }
    if (undefinedFound) return undefined;
    return false;
  }

  // Find all rules which match and delegate to `getBestMatch()` to pick the best one.
  parse(scope, tokens) {
    if (DEBUG) console.group(`matching '${this.argument || this.name || this.toSyntax()}'`, tokens);
    if (this.resetRules) scope = scope.resetRules();

    // Try to match each rule in turn.
    // For efficiency, complicated rules (e.g. sequences or recursive rules)
    //  should exit quickly via a `testRule` or similar mechanism.
    const matches = [];
    for (let i = 0, rule; rule = this.rules[i++];) {
      const match = rule.parse(scope, tokens);
      if (match) matches.push(match);
    }

    let match = matches.length > 1 ? this.getBestMatch(matches) : matches[0];

    if (DEBUG && matches.length > 1) matches.forEach((match, index) => console.log(index, match.name, match));
    if (DEBUG && matches.length > 1) console.log("best match:", match);
    if (DEBUG) console.groupEnd();

    if (!match) return;

    // assign special properties to the result
    if (this.argument) match.argument = this.argument;
    if (this.promote) match.promote = this.promote;
    return match;
  }

  // Return the "best" match given more than one matches at the head of the tokens.
  // First we find the match(es) with the highest preceedence.
  // Then we take the one with the longest matched string.
  // If more than one rule with same length, takes LATEST one.
  getBestMatch(matches) {
    if (matches.length === 1) return matches[0];

    // Filter to rules with highest precedence.
    // NOTE: we run this BACKWARDS to put later-defined rules first
    let match;
    let highPriority = [];
    for (let max = -Infinity, i = 0; match = matches[i++];) {
      const { precedence } = match;
      if (precedence > max) {
        max = precedence;
        highPriority = [match];
      }
      else if (precedence === max) {
        highPriority.push(match);
      }
    }

    if (highPriority.length === 1) return highPriority[0];

    // Return the longest rule (???)
    let longest;
    for (let i = highPriority.length; match = highPriority[--i];) {
      if (!longest || match.matchLength >= longest.matchLength) longest = match;
    }
    return longest;
  }

  // Add a rule to the list of choices.
  // Note that we always create a new array when adding!
  addRule(...rules) {
    this.rules = [...this.rules, ...rules];
  }

  toSyntax() {
    const { testLocation, promote, argument, optional } = this.getSyntaxFlags();
    const rules = this.rules.map(rule => rule.toSyntax()).join("|");
    return `${testLocation}(${promote}${argument}${rules})${optional}`;
  }
};

// Alias for `Rule.Choice` used to merge choices together
// when implicitly combining multiple rules under the same name.
// This lets us distinguish between:
//  - actually defining a semantically-meaning "choices" and
//  - smooshing rules together because they share the same name
Rule.Group = class group extends Rule.Choice {};



// Repeating rule.
//  `this.rule` is the rule that repeats.
//  `this.optional` is true if the prodution is optional.
//  `rule.testRule` is a QUICK rule to test if there's any way the sequence can match.
//  `rule.minCount` is the minimum number we need to match successfully.
//  `rule.maxCount` is the maximum number we need to match successfully.
//
//  Note: Returns `undefined` if we don't match at least once.
Rule.Repeat = class repeat extends Rule {
  constructor(props) {
    if (props instanceof Rule) props = { rule: props };
    super(props);
  }

  parse(scope, tokens) {
    if (this.resetRules) scope = scope.resetRules();
    if (this.testAtStart(scope, tokens, 0) === false) return undefined;

    const matched = [];
    let matchLength = 0;

    let remainingTokens = tokens;
    while (remainingTokens.length) {
      let match = this.rule.parse(scope, remainingTokens);
      if (!match) break;
      matched.push(match);
      matchLength += match.matchLength;
      remainingTokens = remainingTokens.slice(match.matchLength);
    }

    // Forget it if nothing matched at all
    if (matched.length === 0) return undefined;
    if (typeof this.minCount === "number" && matched.length < this.minCount) return undefined;
    if (typeof this.maxCount === "number" && matched.length > this.maxCount) return undefined;

    return new Match({
      rule: this,
      matched,
      matchLength,
      scope
    });
  }

  compile(match) {
    return match.matched.map(match => match.compile());
  }

  toSyntax() {
    let { testLocation, promote, argument, optional } = this.getSyntaxFlags();
    const repeatSymbol = this.optional ? "*" : "+";
    const wrapInParens =
      promote ||
      argument ||
      this.rule instanceof Rule.Sequence ||
      (this.rule instanceof Rule.Literals && this.rule.literals.length > 1);

    // don't double-up on parens
    let rule = this.rule.toSyntax();
    if (wrapInParens && rule.startsWith("(") && rule.endsWith(")"))
      rule = rule.slice(1, -1);

    if (wrapInParens)
      return `(${promote}${argument}${rule})${repeatSymbol}`;
    return `${rule}${repeatSymbol}`;
  }
};

// List match rule:   `[<rule><delimiter>]`. eg" `[{number},]` to match `1,2,3`
//  `rule.rule` (required) is the rule for each item,
//  `rule.delimiter` (required) is the delimiter between each item, which is optional at the end.
Rule.List = class list extends Rule {
  parse(scope, tokens) {
    if (this.resetRules) scope = scope.resetRules();
    if (this.testAtStart(scope, tokens, 0) === false) return undefined;

    let matched = [];
    let matchLength = 0;
    let remainingTokens = tokens;
    while (remainingTokens.length) {
      // get next item, exiting if not found
      let item = this.rule.parse(scope, remainingTokens);
      if (!item) break;

      matched.push(item);
      matchLength += item.matchLength;
      remainingTokens = remainingTokens.slice(item.matchLength);

      // get delimiter, exiting if not found
      let delimiter = this.delimiter.parse(scope, remainingTokens);
      if (!delimiter) break;
      // NOTE: we do not push the delimiter into matched, but we do count it's length.
      matchLength += delimiter.matchLength;
      remainingTokens = remainingTokens.slice(delimiter.matchLength);
    }

    // If we didn't get any matches, forget it.
    if (matched.length === 0) return undefined;

    return new Match({
      rule: this,
      matched,
      matchLength,
      scope
    });
  }

  // Returns JS Array of matched items as source.
  compile(match) {
    return match.matched.map(match => match.compile());
  }

  getInputText(match) {
    return match.matched.map(match => match.inputText);
  }

  toSyntax() {
    const { testLocation, promote, argument, optional } = this.getSyntaxFlags();
    const rule = this.rule instanceof Rule.Sequence
      ? `(${this.rule.toSyntax()})`
      : this.rule.toSyntax();
    const delimiter = this.delimiter.toSyntax();
    return `${testLocation}[${promote}${argument}${rule}${delimiter}]${optional}`;
  }
};


// `start` (required) is the start token string
// `end` (required) is the end token string
// `rule` (required) is the middle bit, which is probably a sequence
// Returns the match of the rule, with `matchLength` adjusted for the delimiters
Rule.Nested = class nesting extends Rule {
  parse(scope, tokens) {
    if (this.resetRules) scope = scope.resetRules();

    const end = this.findNestedEnd(scope, tokens);
    if (end === undefined) return;
    const match = this.rule.parse(scope, tokens.slice(1, end));
    if (!match) return;
    // if we didn't get everything, forget it
    if (match.matchLength + 1 !== end) return undefined;
    // account for the start and end delimiters
    match.tokens = tokens;
    match.matchLength += 2;
    return match;
  }

  // If tokens starts with our `start` literal,
  //  find the index of the token which matches our `end` literal.
  // Returns `undefined` if not found or not balanced.
  findNestedEnd(scope, tokens, start = 0) {
    if (!this.start.testAtStart(scope, tokens, start)) return undefined;
    let nesting = 0;
    for (let end = start + 1, token; token = tokens[end]; end++) {
      if (this.start.testAtStart(scope, tokens, end)) {
        nesting++;
      }
      if (this.end.testAtStart(scope, tokens, end)) {
        if (nesting === 0) return end;
        nesting--;
      }
    }
    return undefined;
  }
}

// `start` (required) is the start token string
// `end` (required) is the end token string
// `rule` (required) is the middle bit, which is probably a sequence
// `delimiter` (optional) if provided, we'll split on this string and apply `rule` to each item inside
// `prefix` (optional) optional array of rules to match inside the FIRST item
//
// If nested start/end blocks are found, WHAT WILL HAPPEN???
Rule.NestedSplit = class nesting extends Rule.Nested {
  parse(scope, tokens) {
    if (this.resetRules) scope = scope.resetRules();

    const end = this.findNestedEnd(scope, tokens);
    if (end === undefined) return;

    const tokenGroups = this.splitTokens(scope, tokens.slice(1, end));
    if (tokenGroups === undefined) return;

//console.warn(tokenGroups);

    let prefix;
    const groups = [];
    for (let i = 0, tokenGroup; tokenGroup = tokenGroups[i]; i++) {
      // For the first item only, match the `prefix` rules if supplied
      if (i === 0 && this.prefix) {
        prefix = this.prefix.parse(scope, tokenGroup);
        if (!prefix && !prefix.optional) return undefined;
        if (prefix) tokenGroup = tokenGroup.slice(prefix.matchLength);
      }
      const match = this.rule.parse(scope, tokenGroup);
      if (!match) return undefined;

      if (match.matchLength !== tokenGroup.length) {
// console.warn(match.compile());
// console.warn("didn't consume enough:", tokenGroup.splice(match.matchLength).map(token => token.value));
// console.warn(scope.rules.rule);
        return undefined;
      }
      groups.push(match);
    }
    return new Match({
      rule: this,
      prefix,
      groups,
      matchLength: end + 1,
      scope
    });
  }

  getResults({ rule, prefix, groups }) {
    const results = prefix && prefix.compile() || {};
    const name = rule.rule.argument || rule.rule.name;
    results[name] = groups.map(group => group.compile());
    return results;
  }

  // If no explcit compile method, return our `results` for someone else to consume.
  compile(match) {
    return this.getResults(match);
  }

  getInputText(match) {
    return match.matched.map(match => match.inputText);
  }

  // If tokens starts with our `start` literal,
  //  find the index of the token which matches our `end` literal.
  // Returns `undefined` if not found or not balanced.
  splitTokens(scope, tokens) {
    const groups = [];
    let current = [];
    for (let i = 0, token; token = tokens[i]; i++) {
      // handle alternate marker
      if (this.delimiter.testAtStart(scope, tokens, i)) {
        groups.push(current);
        current = [];
        continue;
      }
      // handle nested start/emd
      if (this.start.testAtStart(scope, tokens, i)) {
        const end = this.findNestedEnd(scope, tokens, i);
        if (end) {
          current = current.concat(tokens.slice(i, end + 1));
          i = end;
          continue;
        }
      }
      current.push(token);
    }
    // Pick up the last list ONLY if it's not empty
    // This ensures we don't pick up an empty list for a delimiter at the end.
    if (current.length) groups.push(current);

    if (!groups.length) return undefined;
    return groups;
  }
}


// Sequence of rules to match.
//  `rule.rules` is the array of rules to match.
//  `rule.testRule` is a QUICK rule to test if there's any way the sequence can match.
Rule.Sequence = class sequence extends Rule {
  constructor(props) {
    if (arguments.length > 1) props = [...arguments];
    if (Array.isArray(props)) props = { rules: props };
    super(props);
  }
  parse(scope, tokens) {
    if (this.resetRules) scope = scope.resetRules();
    if (this.test(scope, tokens) === false) return undefined;

    const matched = [];
    let matchLength = 0;

    let remainingTokens = tokens;
    for (let i = 0, rule; rule = this.rules[i++];) {
      // If we're out of tokens, bail if rule is not optional
      if (remainingTokens.length === 0) {
        if (rule.optional) continue;
        return undefined;
      }
      let match = rule.parse(scope, remainingTokens);
      if (!match) {
        if (rule.optional) continue;
        return undefined;
      }

      matched.push(match);
      matchLength += match.matchLength;
      remainingTokens = remainingTokens.slice(match.matchLength);
    }

    // if we get here, we matched all the rules!
    return new Match({
      rule: this,
      matched,
      matchLength,
      scope
    })
  }

  // If no explcit compile method, return our `results` for someone else to consume.
  compile(match) {
    return this.getResults(match);
  }

  //TODOC
  // "gather" matched values into a map in preparation to call `compile(match)`
  getResults({ rule, matched, comment }) {
    if (!matched) return undefined;
    let results = addResults({}, matched);
    if (comment) {
      console.warn(`statement ${rule.name} got comment`, comment);
      results.comment = matched.comment;
    }
    return results;

    function addResults(results, matched) {
      for (let i = 0, match; match = matched[i]; i++) {
        const { promote, name } = match;
        if (promote) {
          addResults(results, match.matched);
        } else {
          if (name == null) continue;

          const source = match.compile();
          // If arg already exists, convert to an array
          if (name in results) {
            if (!Array.isArray(results[name])) {
              results[name] = [results[name]];
            }
            results[name].push(source);
          } else {
            results[name] = source;
          }
        }
      }
      return results;
    }
  }

  //TODOC
  // "gather" matched values into a map in preparation to call `compile(match)`
  getMatches({ rule, matched, comment }) {
    if (!matched) return undefined;
    let results = addResults({}, matched);
    if (comment) {
      console.warn(`statement ${rule.name} got comment`, comment);
      results.comment = matched.comment;
    }
    return results;

    function addResults(results, matched) {
      for (let i = 0, match; match = matched[i]; i++) {
        const { promote, name } = match;
        if (promote) {
          addResults(results, match.matched);
        } else {
          if (name == null) continue;

          // If arg already exists, convert to an array
          if (name in results) {
            if (!Array.isArray(results[name])) {
              results[name] = [results[name]];
            }
            results[name].push(match);
          } else {
            results[name] = match;
          }
        }
      }
      return results;
    }
  }


  // Echo this rule back out.
  toSyntax() {
    const { testLocation, promote, argument, optional } = this.getSyntaxFlags();
    const rules = this.rules.map(rule => rule.toSyntax()).join(" ");
    if (promote || optional || argument)
      return `(${promote}${argument}${rules})${optional}`;
    return `${rules}${optional}`;
  }
};

// Blank line representation in parser output.
Rule.BlankLine = class blank_line extends Rule {
  compile(match) {
    return "\n";
  }
};
