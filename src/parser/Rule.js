//  # Parser Rules
//  Rules can be as simple as a string `Keyword` or a complex sequence of (nested) rules.
//
//  Parse a rule with `rule.parse(scope, tokens, start, end)`.
//  If UNSUCCESSFUL, it will return `undefined`
//  If SUCCESSFUL,   it will return a new `Match()` object which is guaranteed to have:
//    - `match.rule`        : pointer back to the rule.
//    - `match.matched`     : array of *significant* tokens that were actually matched.
//    - `match.matchLength` : number of tokens actually consumed (`matched` may not contain them all)
//    ... and other rule-specific values.
//
//  The match returned can be manipulated with:
//    - `match.compile()`    Return javascript source to interpret the rule.
//
import { isNode } from "browser-or-node";

import Parser from "./Parser.js";
import Match from "./Match.js";
import ParseError from "./ParseError.js";
import Token from "./Token.js";
import Tokenizer from "./Tokenizer.js";
import { isWhitespace } from "../utils/string";

// Show debug messages on browser only.
const DEBUG = !isNode;

// Should we test at the start of the tokens, or anywhere in the range?
export const TestLocation = {
  AT_START: "AT_START",
  ANYWHERE: "ANYWHERE"
};

// Abstract Rule class.
// TODOC
export default class Rule {
  constructor(props) {
    Object.assign(this, props);
  }

  //
  //  Parsing methods -- you MUST implement these in your subclasses!
  //

  // Test to see if there is ANY WAY that we can be found in `tokens` beween `start` and `end`.
  // This used to exit quickly if there is no chance of success,
  //  and is especially useful for rules which call themselves at the start.
  //
  // Returns:
  //  - `true` if the rule MIGHT be matched.
  //  - `false` if there is NO WAY the rule can be matched.
  //  - `undefined` if not determinstic (eg: no way to tell quickly).
  test(scope, tokens, start, end, testLocation) {}

  // Attempt to match this rule between `start` and `end` of `tokens`.
  // If successful, returns a `Match` object which you can use to figure out the results.
  // If unsuccessful, returns `undefined`.
  parse(scope, tokens, start, end) {}

  // Output javascript source for this rule passed a successful `match` generated by it.
  // You may want to look at `match.matched` or `match.results`, etc.
  compile(match) {}

  // Return the precedence for this rule as matched.
  // Override to do something funky (e.g. `infix_operator_expression`)
  getPrecedence(match) {
    return this.precedence || 0;
  }
}

// Abstract rule for matching tokens of a particular type (Token constructor)
Rule.TokenType = class tokenType extends Rule {
  test(scope, tokens, start = 0, end = tokens.length, testLocation = this.testLocation) {
    if (start >= end) return false;
    if (testLocation === TestLocation.ANYWHERE) {
      let token;
      while ((token = tokens[start++])) {
        if (token instanceof this.tokenType) return true;
      }
      return false;
    }
    return (tokens[start] instanceof this.tokenType);
  }

  parse(scope, tokens, start = 0, end) {
    if (!(tokens[start] instanceof this.tokenType)) return;
    return new Match({
      rule: this,
      matched: [tokens[start]],
      matchLength: 1,
      start,
      nextStart: start + 1,
    });
  }

  compile(match) {
    return match.matched[0].value;
  }
}


// Abstract rule to match a single literal value.
// `rule.literal` is either:
//    - string to match, or
//    - array of strings, any of which will work.
Rule.Literal = class literal extends Rule {
  constructor(props) {
    // If passed a string, use that as our `literals`
    if (typeof props === "string") props = { literal: props };
    super(props);
  }

  test(scope, tokens, start = 0, end = tokens.length, testLocation = this.testLocation) {
    if (start >= end) return false;
    if (testLocation === TestLocation.ANYWHERE) {
      for (var index = start; index < end; index++) {
        if (tokens[index].matchesLiteral(this.literal)) return true;
      }
      return false;
    }
    return tokens[start].matchesLiteral(this.literal);
  }

  parse(scope, tokens, start = 0, end) {
    if (!this.test(scope, tokens, start, end, TestLocation.AT_START)) return undefined;
    return new Match({
      rule: this,
      matched: [tokens[start]],
      matchLength: 1,
      start,
      nextStart: start + 1,
    });
  }

  compile(match) {
    return match.matched[0].value;
  }

  toSyntax() {
    const testLocation = this.testLocation === TestLocation.ANYWHERE ? "…" : "";
    const promote = this.promote ? "?:" : "";
    const argument = this.argument ? `${this.argument}:` :"";
    const isChoice = Array.isArray(this.literal);
    const literal = isChoice ? this.literal.join("|") : this.literal;
    const optional = this.optional ? "?" : "";
    if (isChoice || promote || argument)
      return `${testLocation}(${promote}${argument}${literal})${optional}`;
    return `${testLocation}${literal}${optional}`;
  }
};



// Abstract rule for one or more sequential literal values to match.
// `rule.literals`:
//    the literal string or array of literal strings to match.
// `rule.literalSeparator`
//    the string to put between multiple literals when joining multiple literals together.
Rule.Literals = class literals extends Rule {
  constructor(props) {
    // If passed a string, use that as our `literals`
    if (typeof props === "string") props = { literals: props };
    super(props);

    // coerce `literals` to an array
    if (typeof this.literals === "string") {
      this.literals = this.literals.split(this.literalSeparator);
    }
  }

  test(scope, tokens, start = 0, end = tokens.length, testLocation = this.testLocation) {
    if (testLocation === TestLocation.ANYWHERE) {
      for (var index = start; index < end; index++) {
        if (this._testAtStart(tokens, index, end)) return true;
      }
      return false;
    }
    return this._testAtStart(tokens, start, end);
  }

  _testAtStart(tokens, start, end) {
    const literals = this.literals;
    const length = literals.length;
    if (start + length > end) return false;

    // Quick return if only one.
    if (length === 1) return tokens[start].matchesLiteral(literals[0]);

    // if more than one, make sure all the rest match
    for (let i = 0; i < length; i++) {
      if (!tokens[start + i].matchesLiteral(literals[i])) return false;
    }
    return true;
  }

  parse(scope, tokens, start = 0, end = tokens.length) {
    if (!this._testAtStart(tokens, start, end)) return undefined;

    // Return actual tokens matched
    const nextStart = start + this.literals.length;
    return new Match({
      rule: this,
      matched: tokens.slice(start, start + this.literals.length),
      matchLength: this.literals.length,
      start,
      nextStart,
    });
  }

  compile(match) {
    return match.matched
      .map(match => match.value)
      .join(this.literalSeparator);
  }

  toSyntax() {
    const testLocation = this.testLocation === TestLocation.ANYWHERE ? "…" : "";
    const promote = this.promote ? "?:" : "";
    const argument = this.argument ? `${this.argument}:` :"";
    const isChoice = this.isChoice;
    const literals = this.literals.join(this.literalSeparator);
    const optional = this.optional ? "?" : "";
    if (promote || argument)
      return `${testLocation}(${promote}${argument}${literals})${optional}`;
    return `${testLocation}${literals}${optional}`;
  }
};
Object.defineProperty(Rule.Literals.prototype, "literalSeparator", { value: "" });

// One or more literal symbols: `<`, `%` etc.
// Symbols join WITHOUT spaces.
Rule.Symbols = class symbols extends Rule.Literals {};

// One or more literal keywords.
// Keywords join WITH spaces.
Rule.Keywords = class keywords extends Rule.Literals {
  constructor(props) {
    super(props);
    // If we got exactly one literal, return a Rule.Literal instead which should be faster
    if (this.literals && this.literals.length === 1) {
      const props = {...this};
      props.literal = props.literals[0];
      delete props.literals;
      return new Rule.Literal(props);
    }
  }
};
Object.defineProperty(Rule.Keywords.prototype, "literalSeparator", { value: " " });

// Regex pattern to match a SINGLE token.
// `rule.pattern` is the regular expression to match.
//    Note that you MUST start your pattern with `^` and end with `$` to make sure it matches the entire token.
//    Note that this can only match a single token!
// `rule.blacklist` is a map of `{ key: true }` for strings which will NOT be accepted.
// `rule.valueMap` can be either:
//    - a map of `{ <matchedValue>: <returnValue> }` to map result output, or
//    - a `function(value) => newValue` used to transform the matched value.
Rule.Pattern = class pattern extends Rule {
  constructor(props) {
    super(props);
    // convert blacklist to a map if necessary
    if (Array.isArray(this.blacklist)) {
      this.blacklist = this.blacklist.reduce((map, key) => {
        map[key] = true;
        return map;
      }, {});
    }
  }

  test(scope, tokens, start = 0, end = tokens.length, testLocation = this.testLocation) {
    if (start >= end) return false;
    if (testLocation === TestLocation.ANYWHERE) {
      for (var index = start; index < end; index++) {
        if (tokens[index].matchesPattern(this.pattern, this.blacklist)) return true;
      }
      return false;
    }
    return tokens[start].matchesPattern(this.pattern, this.blacklist);
  }

  parse(scope, tokens, start = 0, end = tokens.length) {
    if (start >= end) return;
    if (!tokens[start].matchesPattern(this.pattern, this.blacklist)) return undefined;
    return new Match({
      rule: this,
      matched: [tokens[start]],
      matchLength: 1,
      start,
      nextStart: start + 1,
    });
  }

  compile(match) {
    const value = match.matched[0].value;
    if (!this.valueMap) return value;
    if (typeof this.valueMap === "function") return this.valueMap(value);
    return this.valueMap[value];
  }
};

// Subrule -- name of another rule to be called.
// `rule.subrule` is the name of the rule in `scope.rules`.
//
// After parsing
//  we'll return the actual rule that was matched (rather than a clone of this rule)
Rule.Subrule = class subrule extends Rule {
  constructor(props) {
    // If passed a string, use that as our `subrule`
    if (typeof props === "string") {
      super();
      this.subrule = props;
    }
    else {
      super(props);
    }
  }

  // Ask the subrule to figure out if a match is possible.
  test(scope, tokens, start, end, testLocation = this.testLocation) {
    const rule = scope.getRuleOrDie(this.subrule);
    return rule.test(scope, tokens, start, end, testLocation);
  }

  parse(scope, tokens, start = 0, end = tokens.length) {
    if (start >= end) return;

    // if we have any excludes, get a clone of the scope without those rules
    if (this.excludes) {
      scope = scope.cloneExcludingRules(this.subrule, this.excludes);
    }
    let rule = scope.getRuleOrDie(this.subrule);

    const match = rule.parse(scope, tokens, start, end);
    if (!match) return undefined;
    if (this.argument) match.argument = this.argument;
    if (this.promote) match.promote = this.promote;
    return match;
  }

  toSyntax() {
    const testLocation = this.testLocation === TestLocation.ANYWHERE ? "…" : "";
    const promote = this.promote ? "?:" : "";
    const argument = this.argument ? `${this.argument}:` : "";
    const excludes = this.excludes ? `!${this.exludes.join("!")}:` : "";
    const optional = this.optional ? "?" : "";
    return (
      `${testLocation}{${argument}${this.subrule}${excludes}}${optional}`
    );
  }
};

// Alternative syntax, matching one of a number of different rules.
// The result of a parse is the longest rule that actually matched.
// NOTE: Currently takes the longest valid match.
// TODO: match all valid choices
//
// After parsing
//  we'll return the rule which is the "best match" (rather than cloning this rule).
Rule.Choice = class choices extends Rule {
  constructor() {
    super(...arguments);
    if (!this.rules) this.rules = [];
  }

  // Return (`true` or index) if ANY of our rules is found.
  // If ANY rules return `undefined`, this will return `undefined`.
  // If ALL rules return `false`, this will return `false`.
  test(scope, tokens, start, end, testLocation = this.testLocation) {
    let undefinedFound = false;
    for (let i = 0, rule; rule = this.rules[i]; i++) {
      const result = rule.test(scope, tokens, start, end, testLocation);
      if (result === undefined) undefinedFound = true;
      else if (result !== false) return result;
    }
    if (undefinedFound) return undefined;
    return false;
  }

  // Find all rules which match and delegate to `getBestMatch()` to pick the best one.
  parse(scope, tokens, start = 0, end = tokens.length) {
    if (start >= end) return;
    if (DEBUG) console.group(`matching choices ${this.argument || this.name || this.toSyntax()} at ${start}`);
    const matches = [];
    for (let i = 0, rule; rule = this.rules[i]; i++) {
      let match = rule.parse(scope, tokens, start, end);
      if (match) matches.push(match);
//      if (DEBUG && match) console.log(rule.name, match);
    }

    let match = matches.length > 1 ? this.getBestMatch(matches) : matches[0];

    if (DEBUG && matches.length > 1) matches.forEach((match, index) => console.log(index, match.name, match));
    if (DEBUG && matches.length > 1) console.log("best match:", match);
    if (DEBUG) console.groupEnd();

    if (!match) return;

    // assign special properties to the result
    if (this.argument) match.argument = this.argument;
    if (this.promote) match.promote = this.promote;
    return match;
  }

  // Return the "best" match given more than one matches at the head of the tokens.
  // First we find the match(es) with the highest preceedence.
  // Then we take the one with the longest matched string.
  // If more than one rule with same length, takes LATEST one.
  getBestMatch(matches) {
    if (matches.length === 1) return matches[0];

    // Filter to rules with highest precedence.
    // NOTE: we run this BACKWARDS to put later-defined rules first
    let match;
    let highPriority = [];
    for (let max = -Infinity, i = 0; match = matches[i++];) {
      const { precedence } = match;
      if (precedence > max) {
        max = precedence;
        highPriority = [match];
      }
      else if (precedence === max) {
        highPriority.push(match);
      }
    }

    if (highPriority.length === 1) return highPriority[0];

    // Return the longest rule (???)
    let longest;
    for (let i = highPriority.length; match = highPriority[--i];) {
      if (!longest || match.matchLength >= longest.matchLength) longest = match;
    }
    return longest;
  }

  addRule(...rule) {
    if (!this.rules) this.rules = [];
    this.rules.push(...rule);
  }

  toSyntax() {
    const testLocation = this.testLocation === TestLocation.ANYWHERE ? "…" : "";
    const promote = this.promote ? "?:" : "";
    const argument = this.argument ? `${this.argument}:` : "";
    const rules = this.rules.map(rule => rule.toSyntax()).join("|");
    const optional = this.optional ? "?" : "";
    return `${testLocation}(${promote}${argument}${rules})${optional}`;
  }
};

// Alias for `Rule.Choice` used to merge choices together
// when implicitly combining multiple rules under the same name.
// This lets us distinguish between:
//  - actually defining a semantically-meaning "choices" and
//  - smooshing rules together because they share the same name
Rule.Group = class group extends Rule.Choice {};



// Repeating rule.
//  `this.repeat` is the rule that repeats.
//  `this.optional` is true if the prodution is optional.
//  `rule.testRule` is a QUICK rule to test if there's any way the sequence can match.
//
//  Note: Returns `undefined` if we don't match at least once.
Rule.Repeat = class repeat extends Rule {
  // Check `testRule` if provided.
  test(scope, tokens, start, end, testLocation = this.testLocation) {
    if (this.testRule) return this.testRule.test(scope, tokens, start, end, testLocation);
  }

  parse(scope, tokens, start = 0, end = tokens.length) {
    tokens = tokens.slice(start, end);
    // Bail quickly if no chance
    if (this.test(scope, tokens) === false) return undefined;

    const matched = [];
    let matchLength = 0;

    while (tokens.length) {
      let match = this.repeat.parse(scope, tokens);
      if (!match) break;
      // TODO... don't think this could happen...
      if (match.matchLength === 0) {
        throw new TypeError(`repeat rule ${this.name}: got unproductive match`);
      }
      matched.push(match);
      matchLength += match.matchLength;
      tokens = tokens.slice(match.matchLength);
    }

    // Forget it if nothing matched at all
    if (matched.length === 0) return undefined;

    return new Match({
      rule: this,
      matched,
      matchLength,
      start,
      nextStart: start + matchLength
    });
  }

  compile(match) {
    return match.matched.map(match => match.compile());
  }

  toSyntax() {
    const testLocation = this.testLocation === TestLocation.ANYWHERE ? "…" : "";
    const isCompoundRule =
      this.repeat instanceof Rule.Sequence ||
      (this.repeat instanceof Rule.Literals && this.repeat.literals.length > 1);
    const repeat = this.repeat.toSyntax();
    const rule = isCompoundRule ? `(${repeat})` : `${repeat}`;
    const optional = this.optional ? "*" : "+";
    return `${testLocation}${rule}${optional}`;
  }
};

// List match rule:   `[<item><delimiter>]`. eg" `[{number},]` to match `1,2,3`
//  `rule.item` is the rule for each item,
//  `rule.delimiter` is the delimiter between each item, which is optional at the end.
Rule.List = class list extends Rule {
  // Check `testRule` if provided.
  test(scope, tokens, start, end, testLocation = this.testLocation) {
    if (this.testRule) return this.testRule.test(scope, tokens, start, end, testLocation);
  }

  parse(scope, tokens, start = 0, end = tokens.length) {
    if (start >= end) return;
    // Bail quickly if no chance
    if (this.test(scope, tokens, start, end) === false) return undefined;

    // ensure item and delimiter are optional so we don't barf in `parseRule`
    //TODO: ???
    this.item.optional = true;
    this.delimiter.optional = true;

    let matched = [];
    let matchLength = 0;
    let nextStart = start;
    while (nextStart < end) {
      // get next item, exiting if not found
      let item = this.item.parse(scope, tokens, nextStart, end);
      if (!item) break;

      matched.push(item);
      matchLength += item.matchLength;
      nextStart = item.nextStart;

      // get delimiter, exiting if not found
      let delimiter = this.delimiter.parse(scope, tokens, nextStart, end);
      if (!delimiter) break;
      // NOTE: we do not push the delimiter into matched, but we do count it's length.
      matchLength += delimiter.matchLength;
      nextStart = delimiter.nextStart;
    }

    // If we didn't get any matches, forget it.
    if (matched.length === 0) return undefined;

    return new Match({
      rule: this,
      matched,
      matchLength,
      start,
      nextStart,
    });
  }

  // Returns JS Array of matched items as source.
  //TODO: `JSDelimiter` to return as a single string?
  compile(match) {
    if (!match.matched) return [];
    return match.matched.map(match => match.compile());
  }

  toSyntax() {
    const testLocation = this.testLocation === TestLocation.ANYWHERE ? "…" : "";
    const promote = this.promote ? "?:" : "";
    const argument = this.argument ? `${this.argument}:` : "";
    const item = this.item.toSyntax();
    const delimiter = this.delimiter.toSyntax();
    const optional = this.optional ? "?" : "";
    return `${testLocation}[${promote}${argument}${item} ${delimiter}]${optional}`;
  }
};


// Sequence of rules to match.
//  `rule.rules` is the array of rules to match.
//  `rule.testRule` is a QUICK rule to test if there's any way the sequence can match.
Rule.Sequence = class sequence extends Rule {
  test(scope, tokens, start, end, testLocation = this.testLocation) {
    if (this.testRule) return this.testRule.test(scope, tokens, start, end, testLocation);
  }

  parse(scope, tokens, start = 0, end = tokens.length) {
    if (start >= end) return;

    // Bail quickly if no chance
    if (this.test(scope, tokens, start, end) === false) return undefined;
    const matched = [];
    let matchLength = 0;

    // Match each token in turn
    let nextStart = start;
    for (let i = 0, rule; rule = this.rules[i]; i++) {
      // If we're beyond the end, bail if rule is not optional
      if (nextStart >= end) {
        if (rule.optional) continue;
        return undefined;
      }
      let match = rule.parse(scope, tokens, nextStart, end);
      if (!match && !rule.optional) return undefined;
      if (match) {
        matched.push(match);
        matchLength += match.matchLength;
        nextStart = match.nextStart;
      }
    }

    // if we get here, we matched all the rules!
    return new Match({
      rule: this,
      matched,
      matchLength,
      start,
      nextStart,
    })
  }

  // You MUST override `compile` in your sequence rule if it is ever going to be called directly.
  compile(match) {
    throw new ParseError(`Sequence ${this.name} MUST provide a compile() method`)
  }

  //TODOC
  // "gather" matched values into a map in preparation to call `compile(match)`
  getResults({ rule, matched, comment }) {
    if (!matched) return undefined;
    let results = addResults({}, matched);
    if (comment) {
      console.warn(`statement ${rule.name} got comment`, comment);
      results.comment = matched.comment;
    }
    return results;

    function addResults(results, matched) {
      for (let i = 0, match; match = matched[i]; i++) {
        const { promote, name } = match;
        if (promote) {
          return addResults(results, match.matched);
        } else {
          if (name == null) continue;

          const source = match.compile();
          // If arg already exists, convert to an array
          if (name in results) {
            if (!Array.isArray(results[name])) {
              results[name] = [results[name]];
            }
            results[name].push(source);
          } else {
            results[name] = source;
          }
        }
      }
      return results;
    }
  }

  // Echo this rule back out.
  toSyntax() {
    const testLocation = this.testLocation === TestLocation.ANYWHERE ? "…" : "";
    const rules = this.rules.map(rule => rule.toSyntax()).join(" ");
    const optional = this.optional ? "?" : "";
    return `${testLocation}${rules}${optional}`;
  }
};

// A `statement` generally represents a single line of output.
// `statements` automatically parse comments at the end of their line
//  (available as `match.comment`)
Rule.Statement = class statement extends Rule.Group {
  parse(scope, tokens, start = 0, end = tokens.length) {
    if (start >= end) return;

    // eat whitespace at the front of the line
//     let index = start;
//     while (tokens[index] instanceof Token.Whitespace) index++;
//     if (index >= end) return;   // TODO: blank line?

    // eat comment at end of the line
    let comment;
    if ((tokens[end - 1] instanceof Token.Comment)) {
      comment = scope.getRuleOrDie("comment").parse(scope, tokens, end - 1, end);
    }

    const match = super.parse(scope, tokens, start, end);
    if (!match && !comment) return;
    if (!match) return comment;

    if (comment) {
      match.comment = comment;
      match.matchLength += comment.matchLength;
    }
    return match;
  }
}
Rule.Statement.prototype.argument = "statement";


// `Statements` are a special case for a block of `Statement` rules
//  that understand nesting and comments.
//
// This is a top-level construct, e.g. used to parse an entire file.
Rule.Statements = class statements extends Rule {
  // Split statements up into blocks and parse 'em.
  parse(scope, tokens, start = 0, end = tokens.length) {
    var block = Tokenizer.breakIntoBlocks(tokens, start, end);
    return this.parseBlock(scope, tokens, start, block);
  }

  // Parse an entire `block`, returning array of matched elements (NOT as a match).
  // NOTE: we assume we should reset `scope.rules` because we're entering a new parsing context
  parseBlock(scope, tokens, start, block) {
    scope = scope.resetRules();
    const statementRule = scope.getRuleOrDie("statement");

    let matched = [];
    let matchLength = 0;

    block.contents.forEach(item => {
      if (item.length === 0) {
        matched.push(new Rule.BlankLine());
      }
      // got a nested block
      else if (item instanceof Token.Block) {
        const nested = this.parseBlock(scope, tokens, start, item);
        if (!nested) {
          console.info("expected nested result, didn't get anything");
          return;
        }
        nested.indent = item.indent;
        nested.enclose = true;

        // If the last statement is a `BlockStatement`,
        //  give it the block
        const lastStatement = matched[matched.length - 1];
        if (lastStatement.rule instanceof Rule.BlockStatement) {
          lastStatement.block = nested;
          lastStatement.matchLength += nested.matchLength;
        }
        // otherwise just aadd it to the stream
        else {
          console.warn("got a nested block when we weren't expecting one");
          matched.push(nested);
          matchLength += nested.matchLength;
        }
      } else {
        // Got a single statement, parse the entire thing.
//TODO: bail if not the entire line???
        const match = statementRule.parse(scope, item);
        if (match) {
          matched = matched.concat(match);
          matchLength += match.matchLength;
        }
//        else console.warn("parseBlock expected statement, got", match);
      }
    });

    if (matched.length === 0) return undefined;

    const nextStart = matched[matched.length - 1].nextStart;
    return new Match({
      rule: new Rule.Statements(),
      matched,
      matchLength,
      indent: block.indent,
      start,
      nextStart,
    })
  }

  // Output statements match parsed with `parseBlock`
  // Set `match.enclose` to enclose in curly braces
  // Set `match.indent` to add a tab to the start of each line.
  compile(match) {
    let results = [],
      statement;

    for (var i = 0, next; next = match.matched[i]; i++) {
      try {
        statement = next.compile() || "";
      } catch (e) {
        console.error(e);
        console.warn("Error compiling statements: ", match, "statement:", next);
      }

      // Add comment to end of statement if provided
      // NOTE: this loses any whitespace before the comment...
      if (next.comment) {
        statement += " " + next.comment.compile();
      }

      if (isWhitespace(statement)) {
        results.push("");
      } else if (Array.isArray(statement)) {
        results = results.concat(statement);
      } else if (typeof statement === "string") {
        statement = statement.split("\n");
        results = results.concat(statement);
      } else {
        console.warn(
          "blockToSource(): DON'T KNOW HOW TO WORK WITH\n\t",
          statement,
          "\n\tfrom match",
          next
        );
      }
    }
    let lines = (match.indent || match.enclose)
      ? "\t" + results.join("\n\t")
      : results.join("\n");

    if (match.enclose) return `{\n${lines}\n}`;
    return lines;
  }

  // Enclose a single statement.
  static encloseStatement(statement, forceWrap) {
    if (!statement) return "{}";
    if (!forceWrap && !statement.includes("\n") && statement.length < 40) {
      return `{ ${statement.trim()} }`;
    }
    if (statement[0] !== "\t") statement = `\t${statement}`;
    return `{\n${statement}\n}`;
  }
};

// A `BlockStatement` (e.g. an `if` or `repeat`):
//  - is assumed to have an initial partial `statement`
//  - MAY have an inline `statement` (on the same line, possibly after a `:`)
//  - MAY have contents as an embedded `block`
// Note that it's considered an error to have BOTH an inline statement AND a nested block.
//
//  e.g. a `BlockStatement` with syntax `if {expression} then {statement}?` will attemt to:
//  - match the optional `statement` as an inline-statement (as `results.statement`)
//  - match an INDENTED block starting on the next line (as `result.block`)
//
//  For your convenience in `compile()`, you can just look at `results.statements`
//  which will be one of the following (whichever comes first):
//    - the block and its statements, enclosed in curly braces and indented, or
//    - the formatted `statement`, enclosed in curly brackets,
//    - `{}` if neither statement or block was matched.
//
Rule.BlockStatement = class block_statement extends Rule.Sequence {
  // Add `statements` to the results.
  getResults(match) {
    const results = super.getResults(match);
    if (!results) return undefined; // TODO???

    // If we got a block, use that for our `statements`
    const { block } = match;
    if (block) {
      results.statements = block.compile(block);
    }
    // otherwise use the `statement`, if it's empty this will return the empty string.
    else {
      results.statements = Rule.Statements.encloseStatement(results.statement);
    }
    return results;
  }
};

// Blank line representation in parser output.
Rule.BlankLine = class blank_line extends Rule {
  compile(match) {
    return "\n";
  }
};


// Parser error representation in parser output.
Rule.StatementParseError = class parse_error extends Rule {
  constructor(props) {
    super(props);
    if (Parser.WARN) console.warn(this.message);
  }

  get message() {
    if (this.parsed) {
      return (
        "CANT PARSE ENTIRE STATEMENT\n" +
        "PARSED      : `" +
        this.parsed +
        "`\n" +
        "CAN'T PARSE : `" +
        this.unparsed +
        "`"
      );
    }
    return "CAN'T PARSE STATEMENT: `" + this.unparsed + "`";
  }

  compile(match) {
    return "// " + match.message.split("\n").join("\n// ");
  }
};
